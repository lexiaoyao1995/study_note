## 数据库

### 理论范式

1、列不可再分

2、要有主键

3、去除传递依赖

### 如何设计一个关系型数据库

####   索引模块 

##### 为什么要使用索引

快速查询数据

##### 什么信息能成为索引

主键，唯一键，普通键

##### 索引的数据结构

二叉查找树 

bTree进行查找

b+Tree进心查找（Mysql）

Hash结构进行查找

**二叉查找树**

**bTree**

1、根节点至少包括两个孩子

2、树中每个节点最多含有m个孩子（m>=2）

3、除根节点和叶子节点外，其他每个节点至少有ceil（m/2）个孩子

4、所有叶子节点都位于同一层

5、

**b+树**

更适合做存储索引

1、b+树的磁盘读写代价更低

2、b+树的查询效率更加稳定

3、有利于对数据库扫描

##### hash索引

缺点

仅仅满足“=”，不能使用范围查询

遇到hash值相等的情况，性能比较低下

**bitMap 位图索引**

orical数据库采用

#### 密集索引和稀疏索引的区别

密集索引文件中的每个搜索码值都对应一个索引值

稀疏索引文件只为索引码的某些值建立索引项

**InnoDB 有且仅有一个密集索引**

若一个主键被定义，该主键则作为密集索引

若没有主键被定义，该表的第一个唯一非空索引则作为密集索引

若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）

innodb 索引和数据和放在一个文件里的   *MyISAM* 索引和数据是分开放的

### 联合索引 最左匹配原则

mysql会一直向右匹配直到遇到范围查询（< > between like）就停止匹配

比如a=3 and b=4 and c>5 and d=6 如果建立（a,b,c,d）顺序的索引，d是用不到索引的，如果建立的是（abdc）的索引则可以用到，、

其中=和in可以乱序

#### 原因

mysql建立复合索引，先对第一个地段进行排序，再对第二个字段排序，以此构建B+tree，所以如果在中间有范围查询就拿不到最下面的数据，就不能走索引

### 索引是越多越好吗

不是

数据量小的表不需要索引，建立会增加额外的索引开销

变更数据需要维护索引，需要更多维护成本

需要更多空间

### MyISAM和InnoDB关于索方面的区别是什么

1、MyISAM默认的是表级锁，不支持行级锁

2、InnoDB默认用的是行级所，也支持表级锁

锁分为读锁和写锁，读锁也叫共享锁（for update 可强行加排他锁），写锁也叫排他锁

innoDB在sql没有用到索引的时候，用的是表锁

### MyISAM支持的场景

1、频繁执行全表count语句

2、对数据进行增删改的频率不高，查询非常频繁

3、没有事务

### INNODB适合的场景

1、增删改查都比较频繁

2、事务

### 锁的分类

按锁的粒度 分为  表级锁，行级锁，页级锁

按锁级别划分  共享锁 排他锁

按加锁方式  自动锁 显式锁

按操作划分  DML锁 DDL锁

按使用方式分  乐观锁（sql可用version或是时间戳决定） 悲观锁

### 数据事务的四大特性

CAID

原子性 Atomic

一致性 Consistency

隔离性 isolation

持久性 durability（一个事务一旦提交，就能永久保存，数据库故障能回复，redolog文件）

### 事务隔离级别以及各个级别下的并发访问问题

更新丢失  均可避免 包括 read-uncommitted

脏读  Read-committed及其以上

不可重复读  repectable read

幻读 serializable（串行化）

脏读：一个事务读取了另一个事务未提交的数据

不可重复读：一个事务读取数据的前后，由于另一个事务对当前行的更改，对同一行读取的数据不同 

幻读：在事务A执行了一个当前读操作，事务B在事务A的影响区域执行了插入数据的操作，此时，事务A再执行一个当前读操作，就出现了幻行。

## InnoDB可重复读级别下如何避免幻读

**1、使用了快照读（非阻塞读），即伪MVCC**

mvcc是Multi-Version Concurrency Control，多版本并发控制 ，为什么是伪MVCC呢，因为mysql并没有把所有的版本记录下来，而是在undo日志里记录当前活跃的事务。

**2、实际上是next-key（行锁+gap锁）**

gap使用时机：

用在非唯一索引，或是不走索引，或是没有全部命中的主键索引，的当前读中



### 当前读和快照读

当前读：

select ..lock in share mode

select...for update

update

delete

insert

快照读

不加锁的非阻塞读，select（有可能会读到历史数据）

### 快照读的原理

1、利用了数据行的隐藏列  DB_TRX_ID  DB_ROLL_PTR  DB_ROW_ID

2、undo日志 undolog：对数据产生了变更操作时，就会产生undolog，存储的是历史数据

insert undolog

update undolog

3、read view

在RR级别下，第一条快照读，会创建一条快照，read view，将系统中其他的活跃的事务记录起来，以后再调用快照读时，还是同一条read view

### 写sql语句

#### 常用

group by

having

count sum max min avg

**group by** 

1、满足“select 子句中的列名必须为分组列或是列函数”

2、列函数对于group by子句定义的每个组各返回一个结果

**having**

1、通常和group by子句一起使用

2、where过滤行，having过滤组

3、出现在同一sql的顺序，where>group by>having