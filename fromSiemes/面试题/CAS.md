### Q:什么是CAS

CAS是乐观锁的一种思路，假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键。

Compare and Swap 即比较交换

工作流程：

包含三个参数，

V 表示要更新的变量

E 表示预期值

N 表示新值

如果V值等于E值，则将V的值设为N。若V和E不同，则说明已经有其他线程做了更新，则当前线程什么都不做，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作。

通俗的说，就是CAS操作需要我们提供一个期望值，当期望值和当前线程的变量值相同的时候，说明还没有线程修改该值，当前线程可以进行修改，也就是执行cas操作，但如果期望值与当前线程不符，则说明该值已经被其他线程修改了，此时不执行更新操作，但可以选择重新读取该变量再尝试其他修改该变量，也可以放弃操作、

由于无锁操作没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。



### Unsafe类

CAS的操作执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是Native的，主要功能是：

1、内存管理

2、变量的操作

#### 和CAS相关的API

compareAndSwapObject

compareAndSwapInt

park

unpark

将一个线程挂起是通过park方法实现的，调用park后，线程将一直阻塞到超时或是中断等条件出现，

unpark则是终止一个线程的挂起。

Atomic系列内部就是基于下述方法实现的



#### Atomic类的底层就是通过Unsafe实现的，思路是CAS



### CAS的ABA问题及其解决方法

当第一个线程执行CAS（V,E,U）操作，在获取到当前变量V，准备修改为新值U前，另外两个线程已连续修改了两次变量V的值，使得改值又恢复为旧值。

#### 解决方法

AtomicStampedReference类是一个带有时间戳的对象引用，在每次修改后，不仅会设置新值而且会对记录更改的时间记录。当这个类要设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功。





