## 缓存中间件-Memcache和Redis的区别

#### Memcache：代码层次类似Hash

1、支持简单数据类型

2、不支持数据持久化

3、不支持主从

4、不支持分片

#### Redis

1、数据类型丰富

2、支持数据持久化

3、支持主从

4、支持分片

## 为什么Redis能那么快

#### 100000+QPS（QPS query per second）

1、完全基于内存，大部分请求是纯粹的内存操作，执行效率高

2、数据结构简单，对数据操作也简单

3、采用单线程，单线程也能处理高并发请求（主线程是单线程，io处理），想多核也可以启动多实例，避免上下文切换和锁竞争

4、采用多路IO复用模型，非阻塞io

## 多路IO复用模型

#### FD：file descriptor 文件描述符

#### Select系统调用

#### Redis采用的IO多路复用函数：epoll   kqueue   evport    select？

1、优先选择时间复杂度为O（1）的io多路复用函数作为底层实现

2、以时间复杂度为O(n)的select作为保底

## 说说你用过的Redis数据类型

#### 供用户使用的数据类型

1、string 容量最大513M  jpg图片，序列化对象

底层是C语言  sdshdr 结构体  

2、Hash String元素组成的字典，适合存储对象

3、list   列表 按照String元素插入顺序排序

4、set String元素组成的无序集合，通过hash表通过hash表实现，不允许重复

5、Sorted Set 通过分数来为集合中的成员进行从小到大排序

6、高级类型    

用于计数的HyperLogLog ，用于支持存储地理位置信息的Geo

#### 底层数据类型基础

1、简单动态字符串

2、链表

3、字典

4、跳跃表

5、整数集合

6、压缩列表

7、对象



## 从海量key里查询出某一固定前缀的key

留意细节   数据量

1、keys pattern：查找所有符合给定模式的pattern的key

keys一次性返回所有匹配的key

建的数量过大会使得内存卡顿

2、scan cursor 【Match pattern】【Count count】

基于**游标**cursor的迭代器，需要基于上一次的游标延续之前的迭代过程

以0左右游标开始一次新的迭代，直到命令返回游标0完成一次遍历

不保证每次执行都返回某个给定数量的元素，支持模糊查询

一次返回的数量不可控，只能是大概率符合count参数

## 如何通过redis实习分布式锁

### 分布式锁需要解决的问题

1、互斥性

2、安全性

3、死锁

4、容错

### SETNX key value ： 如果key不存在，则创建并赋值，原子性

### 如何解决setnx长期有效的问题

expire key seconds 

设置key的生存时间，



先用setnx再用expire，不是原子性

set key value 【EX seconds】 【PX milliseseconds】 【NX|XX】

NX 只有在建不存在时才返回1 类似于setnx

解决了原子性



## 大量的key需要同时过期

集中过期，由于清除大量的key很耗时，会出现短暂的卡顿

解决方案：在设置key的过期时间的时候，给每一个key加上随机值，让其分散过期。





## 如何使用Redis做异步队列

#### 使用list作为队列，rpush生产消息，lpop消费消息

缺点：没有等待队列里有值就直接消费

弥补：可以通过在应用层引入sleep机智去调用lpop重试

#### blpop key timeout ：阻塞直到队列有消息或者超时

缺点：只能供一个消费者消费

#### pub/sub：主题订阅模式

发送者pub发送消息，订阅者sub接受消息

订阅者可以订阅任意数量的频道

缺点：消息的发布是无状态的，无法保证可达



## Redis如何做持久化

#### RDB redis database （快照）持久化：保存某个时间点的全量数据快照

1、save：阻塞redis的服务器进程，直到rdb文件被创建完毕

2、bgsave：fork出一个子进程来创建rdb文件，不阻塞服务器进程，可用lastsave查看上一次rdb时间

#### 自动化触发rdb持久化的方式

1、根据redis.conf配置里的save m n定时触发

2、主从复制时，主节点自动触发

3、执行Debug reload

4、执行shutdown且没有开启aof持久化

#### bgsave原理

系统调用fork，创建进程，实现copy-on-write

### aof  append only file持久化：保存写操作

记录下除了查询以外的所有变更数据库状态的指令

以append的形式追加到aof文件中（增量）



#### 日志重写解决aof文件大小不断增大的问题，原理如下：

1、调用fork()，创建一个子进程

2、子进程把新的aof写到一个临时文件中，不依赖原理的aof

3、子进程持续把新的变动同时写到内存和原来的aof中

4、主进程获取子进程重写aof的完成信号，往新aof同步增量变动

5、使用新的aof文件替换掉旧的aof文件



#### rdb和aof文件共存情况下的恢复流程

优先使用aof



#### rdb和aof的优缺点

rdb优点：全量数据快照，文件小，恢复快

rdb缺点：无法保存最近一次快照之后的数据

aof优点：可读性高，适合保存增量数据，数据不易丢失

aof缺点：文件体积大，恢复时间长



#### rdb-aof混合持久化方式

先以rdb写入全量数据，再以aof写入增量数据



## 使用pipeline的好处

-pipe

pipeline和linux的管道类似

redis基于请求/相应模型，单个请求处理需要一一应答

pipeline批量执行指令，节省多次io往返时间



## redis同步机制

#### 主从同步原理

分为全同步过程和增量同步过程

#### 全同步过程

1、salve发送sync命令到master

2、master启动一个后台进程，将redis中的数据快照保存到文件中

3、master将保存数据快照期间接收到的写命令缓存起来

4、master完成写操作后，将该文件发送给salve

5、使用新的aof文件替换掉旧的aof文件

6、master将这期间收集的增量写命令发送给salve端

#### 增量同步过程

1、master接收到用户的操作指令，判断是否需要传播到slave中（增删改）

2、将操作记录追加到aof文件中

3、将操作传播到其他slave：对齐主从库，往相应缓存写入指令

4、将缓存中的数据发送给slave



### Redis Sentinel（哨兵模式）

目录下新建sentinel.conf文件

解决了主从同步master宕机后的主从切换问题

1、监控：检查主从服务器是否运行正常

2、提醒：通过api向管理员或者其他应用程序发送故障通知

3、自动故障迁移：主从切换



### redis集群原理

分片：按照某种规则去划分数据，分散存储在多个节点上，采用无中心结构，节点之间使用gosee协议，传播信息以及发现新的节点。

在解决分布式系统中负载均衡的问题时候可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。

一致性hash算法，对2^32取模，将hash值空间组织成虚拟的圆环

当用户在客户端进行请求时候，首先根据hash(用户id)计算路由规则（hash值），然后看hash值落到了hash环的那个地方，根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip.



### hash环的数据倾斜问题

引入虚拟节点解决数据倾斜问题

为每台服务器计算多次虚拟节点