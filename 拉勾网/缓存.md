![](pic/爱奇艺20190705154305.png)

![](pic/爱奇艺20190705154726.png)

MC内存分为多个slab，slab机制主要是为了避免频繁malloc和free产生内存碎片问题

每种类型的slab用来保存不同大小的对象，每个slab又多个page组成，page的默认大小为1M，所以MC的存储对象对象默认不能超过1M

每个page内分为多个chunk，chunk就是实际用来保存对象的空间

Slab Allocator创建slab的参数有三个，分别是chunk大小的增长因子，chunk大小的初始值，page大小，运行时根据要保存的对象大小来逐个创建slab

##### MC钙化问题

使用MC来保存用户信息，比如单个对象大概是300byte，这是会产生大量384字节大小的slab，运行一段时间后，用户信息增加了一个属性，单个对象大小变成了500字节，这时，在保存对象时需要使用768字节的slab，而MC中的容量大部分都创建了384字节的slab，所以768的比较少，这时虽然384的slab内存大量空闲，但是768slab还是会更具LRU算法频繁地剔除缓存，导致MC的剔除率增高，命中率降低

##### 解决钙化问题

开启MC的auto-move机制，每10秒调整slab

![](pic/爱奇艺20190705160119.png)

##### redis事务

并非严格的事务，保证串行执行事务，并保证严格执行，但是不会回滚

> redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot

![](pic/爱奇艺20190705160950.png)

![](pic/爱奇艺20190705163858.png)

##### 缓存穿透

攻击者用不存在的信息频繁请求接口，导致查询缓存不命中，大量到达db层，在db层不命中，可用空对象标记，防止相同id再次访问，利用bloomfilter，bloomfilter是存在性检测，如果bloomfilter中不存在，那么数据一定不存在

##### 缓存击穿

某个热点数据失效时，大量针对这个数据的请求会穿透到数据源

解决方法

互斥锁更新，同一个进程中针对同一个数据不会并发请求db，减小db压力

![](pic/爱奇艺20190705165545.png)

6、使用redis 的 sorted set，使用时间戳作为score，使用zrangebyscore来使用之前的数据

# ADD

## 缓存中间件-Memcache和Redis的区别

#### Memcache：代码层次类似Hash

1、支持简单数据类型

2、不支持数据持久化

3、不支持主从

4、不支持分片

#### Redis

1、数据类型丰富

2、支持数据持久化

3、支持主从

4、支持分片

## 为什么Redis能那么快

#### 100000+QPS（QPS query per second）

1、完全基于内存，大部分请求是纯粹的内存操作，执行效率高

2、数据结构简单，对数据操作也简单

3、采用单线程，单线程也能处理高并发请求（主线程是单线程，io处理），想多核也可以启动多实例，避免上下文切换和锁竞争

4、采用多路IO复用模型，非阻塞io

## 多路IO复用模型

#### FD：file descriptor 文件描述符

#### Select系统调用

#### Redis采用的IO多路复用函数：epoll   kqueue   evport    select？

1、优先选择时间复杂度为O（1）的io多路复用函数作为底层实现

2、以时间复杂度为O(n)的select作为保底

## 说说你用过的Redis数据类型

#### 供用户使用的数据类型

1、string 容量最大513M  jpg图片，序列化对象

底层是C语言  sdshdr 结构体  

2、Hash String元素组成的字典，适合存储对象

3、list   列表 按照String元素插入顺序排序

4、set String元素组成的无序集合，通过hash表通过hash表实现，不允许重复

5、Sorted Set 通过分数来为集合中的成员进行从小到大排序

6、高级类型    

用于计数的HyperLogLog ，用于支持存储地理位置信息的Geo

#### 底层数据类型基础

1、简单动态字符串

2、链表

3、字典

4、跳跃表

5、整数集合

6、压缩列表

7、对象



## 从海量key里查询出某一固定前缀的key

留意细节   数据量

1、keys pattern：查找所有符合给定模式的pattern的key

keys一次性返回所有匹配的key

建的数量过大会使得内存卡顿

2、scan cursor 【Match pattern】【Count count】

基于**游标**cursor的迭代器，需要基于上一次的游标延续之前的迭代过程

以0左右游标开始一次新的迭代，直到命令返回游标0完成一次遍历

不保证每次执行都返回某个给定数量的元素，支持模糊查询

一次返回的数量不可控，只能是大概率符合count参数

## 如何通过redis实现分布式锁

### 分布式锁需要解决的问题

1、互斥性

2、安全性

3、死锁

4、容错

### SETNX key value ： 如果key不存在，则创建并赋值，原子性

### 如何解决setnx长期有效的问题

expire key seconds 

设置key的生存时间，



先用setnx再用expire，不是原子性

set key value 【EX seconds】 【PX milliseseconds】 【NX|XX】

NX 只有在建不存在时才返回1 类似于setnx

解决了原子性



## 大量的key需要同时过期

集中过期，由于清除大量的key很耗时，会出现短暂的卡顿

解决方案：在设置key的过期时间的时候，给每一个key加上随机值，让其分散过期。





## 如何使用Redis做异步队列

#### 使用list作为队列，rpush生产消息，lpop消费消息

缺点：没有等待队列里有值就直接消费

弥补：可以通过在应用层引入sleep机智去调用lpop重试

#### blpop key timeout ：阻塞直到队列有消息或者超时

缺点：只能供一个消费者消费

#### pub/sub：主题订阅模式

发送者pub发送消息，订阅者sub接受消息

订阅者可以订阅任意数量的频道

缺点：消息的发布是无状态的，无法保证可达



## Redis如何做持久化

#### RDB redis database （快照）持久化：保存某个时间点的全量数据快照

1、save：阻塞redis的服务器进程，直到rdb文件被创建完毕

2、bgsave：fork出一个子进程来创建rdb文件，不阻塞服务器进程，可用lastsave查看上一次rdb时间

#### 自动化触发rdb持久化的方式

1、根据redis.conf配置里的save m n定时触发

2、主从复制时，主节点自动触发

3、执行Debug reload

4、执行shutdown且没有开启aof持久化

#### bgsave原理

系统调用fork，创建进程，实现copy-on-write

### aof  append only file持久化：保存写操作

记录下除了查询以外的所有变更数据库状态的指令

以append的形式追加到aof文件中（增量）



#### 日志重写解决aof文件大小不断增大的问题，原理如下：

1、调用fork()，创建一个子进程

2、子进程把新的aof写到一个临时文件中，不依赖原理的aof

3、子进程持续把新的变动同时写到内存和原来的aof中

4、主进程获取子进程重写aof的完成信号，往新aof同步增量变动

5、使用新的aof文件替换掉旧的aof文件



#### rdb和aof文件共存情况下的恢复流程

优先使用aof



#### rdb和aof的优缺点

rdb优点：全量数据快照，文件小，恢复快

rdb缺点：无法保存最近一次快照之后的数据

aof优点：可读性高，适合保存增量数据，数据不易丢失

aof缺点：文件体积大，恢复时间长



#### rdb-aof混合持久化方式

先以rdb写入全量数据，再以aof写入增量数据



## 使用pipeline的好处

-pipe

pipeline和linux的管道类似

redis基于请求/相应模型，单个请求处理需要一一应答

pipeline批量执行指令，节省多次io往返时间



## redis同步机制

#### 主从同步原理

分为全同步过程和增量同步过程

#### 全同步过程

1、salve发送sync命令到master

2、master启动一个后台进程，将redis中的数据快照保存到文件中

3、master将保存数据快照期间接收到的写命令缓存起来

4、master完成写操作后，将该文件发送给salve

5、使用新的aof文件替换掉旧的aof文件

6、master将这期间收集的增量写命令发送给salve端

#### 增量同步过程

1、master接收到用户的操作指令，判断是否需要传播到slave中（增删改）

2、将操作记录追加到aof文件中

3、将操作传播到其他slave：对齐主从库，往相应缓存写入指令

4、将缓存中的数据发送给slave



### Redis Sentinel（哨兵模式）

目录下新建sentinel.conf文件

解决了主从同步master宕机后的主从切换问题

1、监控：检查主从服务器是否运行正常

2、提醒：通过api向管理员或者其他应用程序发送故障通知

3、自动故障迁移：主从切换



### redis集群原理

分片：按照某种规则去划分数据，分散存储在多个节点上，采用无中心结构，节点之间使用gosee协议，传播信息以及发现新的节点。

在解决分布式系统中负载均衡的问题时候可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。

一致性hash算法，对2^32取模，将hash值空间组织成虚拟的圆环

当用户在客户端进行请求时候，首先根据hash(用户id)计算路由规则（hash值），然后看hash值落到了hash环的那个地方，根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip.



### hash环的数据倾斜问题

引入虚拟节点解决数据倾斜问题

为每台服务器计算多次虚拟节点