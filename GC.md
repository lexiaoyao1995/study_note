### 对象被判定为垃圾的标志

没有被其他对象引用

### 判定对象是否为垃圾的算法

#### 引用计数算法

通过判断对象的引用数量来决定是否可以被回收

任何引用数量为0的对象可以被当作垃圾

优势：执行效率高，程序执行受影响小

缺点：无法检测出循环引用的情况，导致内存泄漏

#### 可达性分析算法（主流）

通过判断对象的引用链是否可达来确定是否可以回收（图论）

**gc root**根集合

虚拟机中栈中引用的对象

方法区中常量

### 谈谈你了解的垃圾回收算法

#### 1、标记清除算法

标记：从根集合开始扫描，对存活的对象进行标记

清除：对堆内存从头到尾进行线性遍历，回收不可达的对象

缺点：内存碎片化

#### 2、复制算法

 内存划分为对象面和空闲面

对象主要是在对象面创建

当对象面的内存用完了，把存活的对象从对象面复制到空闲面

把对象面所有对象内存清除

适用于：对象存活率低的场景，比如年轻代

#### 3、标记整理算法

标记：从根集合开始扫描，对存活的对象进行标记

清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。

备注：清除整理算法是标记清除算法上改进，解决了碎片化的问题，但效率不如标记清除算法，适用于老年代。

#### 4、分代收集算法

 包含了多种垃圾回收算法

按照对象生命周期的不同划分区域以采用不同的垃圾回收算法

目的：为了提高jvm的回收效率

jdk8以前 jdk堆内存可以分为年轻代，老年代和永久代

jdk8以后，永久代被去掉了

**分代收集算法的GC分为两种**

minor GC ：新生代的eden区填满后触发 采用复制算法

full GC：老年代 触发条件

1. 老年代空间不足
2. 永久代空间不足 jdk7
3. cms gc出现promotion failed，concurrent mode failure
4. system.gc()    提醒虚拟机希望执行full gc 

**年轻代“尽可能快速地收集那些生命周期短的对象**

eden区   8/10

两个survivor区   2/10

**对象如何晋升到老年代**

进过一定minor次数依然存活的对象   默认15次

survivor区中放不下的对象

新生成的大对象

**常用的调优参数**

-XX:SurvivorRatio  eden和survivor的比例 默认8：1

等

**老年代：存放生命周期较长的对象**

标记清理算法

标记整理算法

**名词 stop-the-world**

1、jvm由于要执行gc而停止了应用程序的执行

2、任何一种gc算法都会发生

3、多数gc优化通过减少stop-the-world发生的实际时间来提高程序性能

**名词 safePoint**

1、分析过程中对象引用关系不会发生变化的点

2、产生safePoint的地方:方法调用，循环，异常

### 常见的垃圾收集器

#### jvm运行模式

1、Server 启动慢，但稳定后速度快

2、Client 启动快，稳定后速度慢

查询 java -version 查询

#### 垃圾收集器之间的关系

##### 年轻代常见的垃圾收集器

**serial收集器 -XX:+useSerialGC 复制算法**

单线程收集，进行收集时，必须暂停其他所有的工作线程

简单高效，client模式下默认

**ParNew -XX:+useParNewGC 复制算法**

多线程收集，主要用于server模式，多用于又用户交互的程序

单核执行效率不如serial，多核下有优势

**Parallel Scavenge -XX：useParallelGC 负责算法**

吞吐量=（系统运行时间）/（系统运行时间+GC等待时间）

尽可能缩短线程停顿时间短，更关注吞吐量

server模式下，默认模式

+XX：useAdaptiveSizePolicy  自适应调节参数

##### 老年代常见收集器

**Serial old 收集器 -xx:+useSerialOldGC 标记整理算法**

单线程

client模式默认收集器

**Parallel Old 收集器（-XX:+UseParallelOldGC）标记整理算法 **

多线程，吞吐量优先

**CMS收集器  -XX：+UseConcMarkSweepGC 标记清除算法**

最常用  减少停顿时间  并发收集器

1、初始化标记：stop-the-world

2、并发标记：并发追溯标记，程序不会停顿

3、并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象

4、重新标记：暂停虚拟机，扫描cms堆中剩余对象 stop-the-world

5、并发清理：清理垃圾对象，程序不会停顿

6、并发重置：重置cms收集器的数据结构



##### **Garbage Firsl收集器 复制+标记整理算法**

新生代和老年代通用

与用户线程并发执行

1、将整个java堆划分为多个大小相等的区域

2、新生代和老年代不再物理隔离



##### jdk11 ZGC 和 Epsilon GC （新的gc）

## 面试题

### object的finalize方法的作用是否与c++的析构函数作用相同

1、与c++的析构函数不同，析构函数调用确定，而它的是不确定的

2、将未被引用的对象放置于f-queue队列

3、方法执行随时可能会被终止

4、给与对象最后一次重生的机会

### java中的强引用，软引用，弱引用和虚引用有什么用

#### 1、强引用

最普遍的引用

Object obj = new Object();

通过将对象obj=null来使其回收

#### 2、软引用

对象处在有用但是非必须的状态

当内存空间不足时，gc会回收该引用的对象的内存

用来高速缓存

~~~java
String str = new String("demo");
SoftReference<String> softRef = new SoftReference<>();
~~~

#### 3、弱引用

比软引用还要弱一些

GC时会被回收

被回收的概率也不大，因为GC线程优先级比较低

WeakReference

#### 4、虚引用

不会决定对象的生命周期

任何时候都可能会被回收

主要作用是跟踪对象被回收的活动，起哨兵的作用

必须和引用队列ReferenceQueue联合使用

~~~java
ReferenceQueue queue = new ReferenceQueue();
PhantomReference ref = new PhantomReference(str,queue);
~~~

**引用队列**

存储被GC的软引用，弱引用，和虚引用