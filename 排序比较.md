| 类别     | 排序方法 | 时间复杂度 | 空间复杂度 | 稳定   |
| :------- | -------- | ---------- | ---------- | ------ |
| 插入排序 | 直接插入 | O(n2)      | O(1)       | 稳定   |
| 插入排序 | 希尔排序 | O(n1.3-2)  | O(1)       | 不稳定 |
| 选择排序 | 直接选择 | O(n2)      | O(1)       | 不稳定 |
| 选择排序 | 堆排序   | O(nlogn)   | O(1)       | 不稳定 |
| 交换排序 | 冒泡排序 | O(n2)      | O(1)       | 稳定   |
| 交换排序 | 快速排序 | O(nlogn)   | O(nlogn)   | 不稳定 |
| 归并排序 |          | O(nlogn)   | O(n)       | 稳定   |
|          |          |            |            |        |

*算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！*



### 插入排序

插入排序的基本思想就是将无序序列插入到有序序列中。

### 希尔排序

希尔排序(Shell's Sort)在插入排序算法的基础上进行了改进，算法的时间复杂度与前面几种算法相比有较大的改进。其算法的基本思想是：先将待排记录序列分割成为若干子序列分别进行插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行一次直接插入排序。

~~~java
public static void shellSort(int[] a){
		int N = a.length;
		
		for(int h = N / 2; h > 0; h /= 2){//希尔增量
			for(int i = h; i < N; i++){
				//将a[i]插入到a[i-h],a[i-2h],a[i-3h]...中
				for(int j = i; j >= h && a[j] < a[j - h]; j -= h){
					int temp = a[j];
					a[j] = a[j-h];
					a[j-h] = temp;
				}
			}
		}
	}
~~~

### 归并排序

采用分治法的思想

“归并”的含义是将两个或两个以上的有序序列组合成一个新的有序表。假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到（表示不小于x的最小整数）个长度为2(或者是1)的有序子序列，再两两归并。如此重复，直到得到一个长度为n的有序序列为止。这种排序方法称为2-路归并排序。
